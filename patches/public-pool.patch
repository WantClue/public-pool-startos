diff --git a/src/services/bitcoin-rpc.service.ts b/src/services/bitcoin-rpc.service.ts
index 2625a7f..14bdfda 100644
--- a/src/services/bitcoin-rpc.service.ts
+++ b/src/services/bitcoin-rpc.service.ts
@@ -102,34 +102,36 @@ export class BitcoinRpcService implements OnModuleInit {
 
     public async getBlockTemplate(blockHeight: number): Promise<IBlockTemplate> {
         let result: IBlockTemplate;
-        try {
-            const block = await this.rpcBlockService.getBlock(blockHeight);
-            const completeBlock = block?.data != null;
-
-            // If the block has already been loaded, and the same instance is fetching the template again, we just need to refresh it.
-            if (completeBlock && block.lockedBy == process.env.NODE_APP_INSTANCE) {
-                result = await this.loadBlockTemplate(blockHeight);
-            }
-            else if (completeBlock) {
-                return Promise.resolve(JSON.parse(block.data));
-            } else if (!completeBlock) {
-                if (process.env.NODE_APP_INSTANCE != null) {
-                    // There is a unique constraint on the block height so if another process tries to lock, it'll throw
-                    try {
-                        await this.rpcBlockService.lockBlock(blockHeight, process.env.NODE_APP_INSTANCE);
-                    } catch (e) {
-                        result = await this.waitForBlock(blockHeight);
+        while (result == null) {
+            try {
+                const block = await this.rpcBlockService.getBlock(blockHeight);
+                const completeBlock = block?.data != null;
+
+                // If the block has already been loaded, and the same instance is fetching the template again, we just need to refresh it.
+                if (completeBlock && block.lockedBy == process.env.NODE_APP_INSTANCE) {
+                    result = await this.loadBlockTemplate(blockHeight);
+                }
+                else if (completeBlock) {
+                    return Promise.resolve(JSON.parse(block.data));
+                } else if (!completeBlock) {
+                    if (process.env.NODE_APP_INSTANCE != null) {
+                        // There is a unique constraint on the block height so if another process tries to lock, it'll throw
+                        try {
+                            await this.rpcBlockService.lockBlock(blockHeight, process.env.NODE_APP_INSTANCE);
+                        } catch (e) {
+                            result = await this.waitForBlock(blockHeight);
+                        }
                     }
+                    result = await this.loadBlockTemplate(blockHeight);
+                } else {
+                    //wait for block
+                    result = await this.waitForBlock(blockHeight);
                 }
-                result = await this.loadBlockTemplate(blockHeight);
-            } else {
-                //wait for block
-                result = await this.waitForBlock(blockHeight);
+            } catch (e) {
+                console.error('Error getblocktemplate:', e.message);
             }
-        } catch (e) {
-            console.error('Error getblocktemplate:', e.message);
-            throw new Error('Error getblocktemplate');
         }
+
         console.log(`getblocktemplate tx count: ${result.transactions.length}`);
         return result;
     }
